---
layout: single
title:  "Chapter1"
---

# 시간복잡도

기준 1초에 1억번의 연산

3가지 표기법 = 오메가 세타 오
빅-오메가 = 최선 
빅-세타 = 평균값
빅-오 = 최악

보통의 시간 복잡도 유형은 빅오 로 수행

로그 100의 연산은 7번 왜? 로그가 제곱인디?
왜 와이? - -  ( 기본적으로 2의 제곱으로 로그 계산이라 2의 7승은 128 로그 100은  128아래 64이상이라 7번으로 된다 )

시간 복잡도를 따지는건 알고리즘 유형에따라 뭔지 
내가짠 코드가 시간 복잡도가 몇인지 알아야한다.

연산횟수 = 알고리즘 시간 복잡도 * 데이터의 크기   ← 이뜻이 2초면 2억번의 연산을 해야하니까 
기준이 2초면 2억번의 연산안에 해결이 가능한 알고리즘을 선택해야한다.

위에 설명에 따르면 알고리즘들이 있고 당장에 써있는 버블 정렬 (N)제곱 과 병합정렬이 n(logn) 인것으로 보아 정렬(알고리즘)들에 대해 알아야할듯 들어본적은 있지만 현재 기억이나지않음

염두할것

상수는 시간복잡도 계산에서 제외 ← ??   ← 예제 에서 반복문의 경우 반복문 5개 즉 5n은 계산에 영향을 많이 안줘서 n으로 계산 즉 상수를 뺀다 단순히 생각했을때 만까지 검수하는 포문하나를 5개 돌리면 5만번이고 포문 한개면 만번인대 이둘이 같다하니까 이건 그런가보다 하고 생각해야할듯


가장많이 중첩된 반복문의 수행횟수가 시간 복잡도의 기준  ← 빅오로 기준잡는다했으니 이해 ← 반복문을 중첩했을때 이중 포문을 5개를 돌려도 크게 계산에 영향을 안줘서 복잡도가 n제곱이란 소리로 이해

시간복잡도 관련해서 체크해야할것 
1. 알맞은 알고리즘 선택하기
2. 비효율적 로직 없게하기

