---
layout: single
title:  "2과목 소프트웨어 개발(1)"
date: 2025-07-24-19:04 
categories:
  - jungcugi
---

### 소프트웨어 개발  

#### 목차  

- 데이터 입출력 구현  
- 통합 구현  
- 제품소프트웨어 패키징  
- 애플리케이션 테스트  
- 인터페이스 구현  


#### 선형/비선형 구조  

- 선형 구조 : 큐(FIFO) , 스택(LIFO), 데크, 리스트, 연결리스트  
- 비선형 구조 : 그래프 , 트리, 인접 행렬  

#### 트리  
  
- 노드       : 트리의 기본 구성 요소  
- 근노드     : 가장 상위에 있는 노드  
- 레벨       : 근노드를 기준으로 특정 노드까지의 경로길이  1부터시작
- 조상 노드  : 어떤 노드에서 근노드에 이르는 경로상의 모든 노드  
- 부모 노드  : 어떤 노드에 연결된 이전 레벨의 노드  
- 자식 노드  : 어떤 노드에 연결된 다음 레벨의 노드  
- 형제 노드  : 같은 부모를 가진 노드  
- 깊이       : 트리의 최대 레벨  0부터시작
- <mark style='background-color: #ffdce0'> 차수       : 어떤 노드에 연결된 자식 노드의 수 </mark>    
- 단말 노드  : 트리의 제일 마지막에 있는 노드 (차수 = 0))  
- <mark style='background-color: #ffdce0'> 트리의 차수: 트리의 노드 중 가장 큰 차수 </mark>  
#### 트리 순회(모든 노드 방문)  

- 전위 순회 : 루트     -> 왼쪽 자식 -> 오른쪽 자식 순서 *뿌리(root)를 먼저 방문  
- 중위 순회 : 왼쪽자식 -> 루트      -> 오른쪽 자식 순서 *왼쪽 하위 트리를 방문 후 뿌리(root)를 방문  
- 후위 순회 : 왼쪽자식 -> 오른쪽자식-> 루트        순서 *하위 트리 모두 방문 후 뿌리(root)를 방문  

예시) 이진트리  
<img width="450" height="333" alt="image" src="https://github.com/user-attachments/assets/f3665037-79fc-4e51-953c-de4ba0c6b4f7" />  

전위 (preorder)   = A -> B -> D -> C -> E -> G -> H -> F  
중위 (inorder)    = D -> B -> A -> G -> E -> H -> C -> F  
후위 (postorder)  = D -> B -> G -> H -> E -> F -> C -> A  

#### 정렬 (알고리즘)

- [선택 정렬](https://taewonstory.github.io/java/chapter7/) : N개의 레코드 중에서 최솟값을 찾아 배열의 첫 번째 위치에 놓고, 이를 반복하여 정렬하는 방법  
- [버블 정렬](https://taewonstory.github.io/java/chapter6/) : 인접한 데이터를 비교하면서 그 크기에 따라 데이터의 위치를 바꾸어 정렬하는 방법  
- [삽입 정렬](https://taewonstory.github.io/java/chapter8/) : 정렬된 파일에 새로운 하나의 레코드를 순서에 따라 삽입시켜 정렬하는 방법

#### 검색 

##### 선형 검색

- 원하는 레코드를 찾을 때까지 처음부터 끝까지 차례로 하나씩 비교하면서 검색한다.
- 데이터가 모인 집합의 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아 내는 알고리즘이다.
- 순차 검색이라고도 한다.
- 단점 : 단순한 방식으로 정렬되지 않는 검색에 가장 유용하며 평균 검색 시간이 많이 소요된다.
- 평균 검색 횟수 : (N +1) / 2

##### 이분 검색 방법

- 탐색 효율이 좋고 탐색 기간이 적게 소요된다.
- 검색할 데이터가 정렬되어 있어야 한다.
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
- 대상 범위의 첫 번째 원소의 위치를 Low로, 마지막 원소의 위치를 High로 두고서 그 중간 원소의 위치인 Mid를 (Low + High) /2 로 구한다.
- 찾고자 하는 Key와 중간값을 비교한다.
- Key > 중간값 : Low를 (Mid +1)로 두고서 계속 수행
- Key < 중간값 : High를 (Mid -1)로 두고서 계속 수행
- Key = 중간값이 될때까지 수행 (검색 완료)
- [이진 탐색](https://taewonstory.github.io/java/chapter14/) 자세한설명

#### 해싱 함수의 종류

- 제산 방법
- 중간 제곱 방법
- 중첩 방법
- 기수 변환 방법
- 무작위 방법
- 계수 분석 방법

#### 단위 테스트

- 하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트이다.
- 애플리케이션을 구성하는 하나의 기능이 올바르게 동작하는 지를 독립적으로 테스트하는 것이다.
- 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
- 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
- 가상모델을 테스트 스텁이라고하는데 이는 단위 테스트완류후 하는 통합테스트이다. 조심할것 (단위테스트가아님) 

##### 지원도구 (떙떙Unit)

- Junit : Java 프로그래밍 언어에 사용 
- Nunit : 모든 .net 언어에 사용
- JMockit : 오픈소스 단위 테스트 도구 기록 및 검증 구문으로 API를 Mocking(가짜로 대체)할수있다.
- EMMA : 코드 분석 오픈소스 툴킷 JAVA기반
- PHPUnit : PHP 프로그래머용
- HttpUnit : Java 프로그램용 Gui가 없는 브라우저를 포함하는 오픈소스 라이브러리.
- DBUnit : 데이터베이스 단위 테스트 지원

#### 블랙박스 테스트 vs 화이트박스 테스트

##### 블랙박스 테스트

- 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완벽히 작동되는 것을 입증하는 테스트(기능테스트)
- 대표적인 명세 기반 기법이다.
- 등가 분할의 경계 부분에 해당하는 입력값에서 결함이 발견될 확률이 경험적으로 높아서 결함을 방지하기 위해 경계값까지 포함하여 테스트하는 기법이다.
- 종류 : <mark style='background-color: #ffdce0'>동치 분할검사, 원인효과 그래프, 오류 예측검사, 비교 검사, 경계값 분석  </mark>

 ##### 화이트박스 테스트

- 모듈의 원시코드를 오픈시킨 상태에서 코드의 논리적 모든 경로를 테스트하는 방법이다.
- 소스 코드의 모든 문장을 한 번 이상 수행함으로써 진행된다.
- 화이트 박스 테스트의 이해를 위해 논리 흐름도를 이용할 수 있다.
- 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트에 해당한다.
- 종류: <mark style='background-color: #ffdce0'>기초 경로 검사, 루프 테스트, 데이터 흐름 테스트, 제어 구조 검사</mark>












